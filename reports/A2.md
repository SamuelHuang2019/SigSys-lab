# Report of Signals and Systems Lab Assignment 2

Written by HUANG Guanchao, SID 11912309 and GONG Xinrui, SID 11911233.

----------------------------------------------------------------

## 2.4

### Basic Problem a

The plots of x1[n],h1[n] and h2[n] are shown below.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nh1 = 0:4;
x1 = [ones(1, 5) zeros(1, 5)];
h1 = [1 -1 3 0 1];
h2 = [0 2 5 4 -1];

subplot(3, 1, 1)
stem(nx1, x1), axis([0, 9, ylim])
xlabel('nx1');
ylabel('Output')
subplot(3, 1, 2), stem(nh1, h1), axis([0, 9, ylim])
xlabel('nh1'); ylabel('Output')
subplot(3, 1, 3), stem(nh1, h2), axis([0, 9, ylim])
xlabel('nh2'); ylabel('Output')

```

----------------------------------------------------------------

### Basic Problem b

The outputs are the same.

We first find convolved x1 with h1, which is `x1[n] * h1[n]`, then we change `x1[n]` into the impulse response and `h1[n]` into the input, and make convolution again, which is `x1[n] * h1[n]`.

The plots for them are shown below, and we can easily figure out that `x1[n] * h1[n]` equals to `x1[n] * h1[n]`.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_b.png)

The MATLAB script is shown above.

```matlab
nx1 = 0:9;
nh1 = 0:4;
x1 = [ones(1,5) zeros(1,5)];
h1 = [1 -1 3 0 1];
h2 = [0 2 5 4 -1];

nw = 0:13;
w1 = conv(x1,h1);
w2 = conv(h1,x1);


subplot(2,1,1),stem(nw,w1),axis([0,13,ylim])
xlabel('nw');ylabel('Output');title('w1[n]=x1[n]*h1[n]')
subplot(2,1,2),stem(nw,w1),axis([0,13,ylim])
xlabel('nw');ylabel('Output');title('w1[n]=h1[n]*x1[n]')

```

----------------------------------------------------------------

### Basic Problem c

The two methods give the same results.

We first convolved `x1[n]*h1[n]` and `x1[n]*h2[n]` separately, and then add them together and find out the plot. After that, we try to add `h1[n]` and `h2[n]` first, and convolved `x1[n]*(h1[n]+h2[n])`.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_c.png)

The two plots are shown above, and we can see that they are exactly the same, which means they have the same results.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nh1 = 0:4;
x1 = [ones(1, 5) zeros(1, 5)];
h1 = [1 -1 3 0 1];
h2 = [0 2 5 4 -1];
h3 = h1 + h2;

nw = 0:13;
w1 = conv(x1, h1) + conv(x1, h2);
w2 = conv(x1, h3);

subplot(2, 1, 1), stem(nw, w1), axis([0, 13, ylim])
xlabel('n_w'); ylabel('w_1')
title('w_1[n] = x_1[n] * h_1[n] + x_1[n] * h_2[n]')
subplot(2, 1, 2)
stem(nw, w2)
axis([0, 13, ylim])
xlabel('n_w')
ylabel('w_2')
title('w_2[n] = x_1[n] * (h_1[n] + h_2[n])')
```

----------------------------------------------------------------

### Basic Problem d

Compairing $y_{d1}[n]$ and $y_{d2}[n]$ ,we have the same results.

First we calculate `x1[n]* h1[n]` and then we use this result to convolved with `h2[n]`.Next we calculate the `h1[n]* h2[n]` firstly and then use the output as the impulse response to convolved with `x1[n]`.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_d.png)

The two plots are shown above, it can be apparently concluded that the output are the same.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nh1 = 0:4;
x1 = [ones(1,5) zeros(1,5)];
h1 = [1 -1 3 0 1];
h2 = [0 2 5 4 -1];

nw = 0:13;

h3 = conv(x1, h1);
h4 = conv(h1, h2);

w1 = conv(h3,h2);
nw1 = 0:17;
w2 = conv(x1,h4);
nw2 = 0:17;

subplot(2,1,1),stem(nw1,w1),axis([0,17,ylim])
xlabel('nw1');ylabel('(x1[n]*h1[n]])*h2[n]');
subplot(2,1,2),stem(nw2,w2),axis([0,17,ylim])
xlabel('nw2');ylabel('x1[n]*(h1[n]*h2[n])');
```

----------------------------------------------------------------

### Intermediate Problem e

For this question, we convolved $x_1[n]*h_{e1}[n]$ and $x_2[n]*h_{e}2[n]$, where $h_{e1}[n]$ and $h_{e2}[n]$ have the relationship $h_{e2}[n] = hg_{e1}[n-n_0]$.

The two plots are shown below.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_e.png)

We can easily conclude from the plots that $y_{e2}[n] = y_{e1}[n-n_0]$.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nh1 = 0:4;
nh2 = 2:6;
x1 = [ones(1,5) zeros(1,5)];
h1 = [1 -1 3 0 1];
h2 = h1;

ny1 = nx1(1)+nh1(1):nx1(end)+nh1(end);
ny2 = nx1(1)+nh2(1):nx1(end)+nh2(end);
y1 = conv(x1,h1);
y2 = conv(x1,h2);

subplot(2,1,1),stem(ny1,y1),axis([0,15,ylim])
xlabel('n');ylabel('ye1 = x1[n]*he1[n]');title('ye1');
subplot(2,1,2),stem(ny2,y2),axis([0,15,ylim])
xlabel('n');ylabel('ye2 = x1[n]*he2[n]');title('ye2');
```

----------------------------------------------------------------

### Intermediate Problem f

To finds out the two outputs, we should first figure out the output of system 1, which is $(n+1).*x_1[n]$. Then we use the output as the input of System 2, and use $h_{f2}[n]$ as the impulse response to get the output $y_{f1}[n]$.

Another try is that we first convolved $h_{f1}[n]$ with $h_{f2}[n]$, then we use the result as the impulse response to convolved with $x_1[n]$, the convolution result is named as $y_{f2}[n]$.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_f.png)

We can easily conclude from the plots that they are not equal to each other.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nhf2 = 0:4;
x1 = [ones(1, 5) zeros(1, 5)];
hf2 = [1 -1 3 0 1];

w = (nx1 + 1) .* x1;

yf1 = conv(w, hf2);
nyf1 = nx1(1) + nhf2(1):nx1(end) + nhf2(end);

xf1 = [1 zeros(1, 4)];
hf1 = (nhf2 + 1) .* xf1;

hseries = conv(hf1, hf2);
nhseries = nhf2(1) + nhf2(1):nhf2(end) + nhf2(end);

yf2 = conv(x1, hseries);
nyf2 = nx1(1) + nhseries(1):nx1(end) + nhseries(end);

subplot(2, 1, 1), stem(nyf1, yf1), axis([0, 17, ylim])
xlabel('n'); ylabel('yf1 = w[n]*hf2[n]'); title('yf1');
subplot(2, 1, 2), stem(nyf2, yf2), axis([0, 17, ylim])
xlabel('n'); ylabel('yf2 = x1[n]*(hf1[n]*hf2[n]'); title('yf2');
```

----------------------------------------------------------------

### Intermediate Problem g

To find out the two output signals, we first need to find out the signal $x_g[n]$, and then use this signal as input signal for System 1 to find out the output signal $y_{ga}[n]$.Then we use the output of System 1 as the input signal for System 2. And the output $y_{gb}[n]$ is the convolution of $y_{ga}[n]$ and $h_{g2}[n]$.$y_{g1}[n]$ is the result of add $y_{ga}[n]$ and $y_{gb}[n]$ together, which is `yg1 = yga + ygb`.

For another try, we first figure out the unit impulse response for System 1 by letting the input signal be unit impulse signal. Then we add this response signal $h_{g1}[n]$  with $h_{g2}[n]$. After that we convolved $x_g[n]$ with this result, so now we get the $y_{g2}[n]$ which is `yg2 = xg * (hg1 + hg2)`.

The two plots for $y_{g1}[n]$ and $y_{g2}[n]$ are shown below.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_g.png)

It is obvious that they are the same, which means $y_{g1}[n] = y_{g2}[n]$.

The MATLAB script is shown below.

```matlab
n = 0:4;
x = [1 zeros(1,4)];
hg2 = [0 2 5 4 -1];
xg = 2.*x;

yga = xg.^2;
ygb = conv(xg,hg2);
nygb = 0:8;
yg1 = [yga zeros(1,4)] + ygb;
nyg1 = 0:8;

hg1 = x.^2;
hparallel = hg1 + hg2;
yg2 = conv(xg,hparallel);
nyg2 = 0:8;

subplot(2,1,1),stem(nyg1,yg1),axis([0,8,ylim])
xlabel('n');ylabel('yg1 = xg*hga + xg*hgb');title('yg1');
subplot(2,1,2),stem(nyg2,yg2),axis([0,8,ylim])
xlabel('n');ylabel('yf2 = xg*(hg1 + hg2)');title('yg2');
```

----------------------------------------------------------------

## 2.5

### Basic Problem a

Basic problems a,b,c use the same Systems, so first we plot the Systems' outputs.

For System 1, it is not easy to figure out the expression for y using x quickly, so use vector to record their index and count the result using `filter`.

The plot is shown below.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_a.png)

For System2, we simply use `cos()` to fing out the result.

The plot is shown below.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_a(2).png)

For System 3, we claculated the results using point multiplicaiton, which is `n.*x[n]`.

The plot is shown below.

![Figure 2.5_a](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_a(3).png)

### Basic Problem b

Since for all three systems the input x3 = x1 + 2*x2, and the output y4 = y1 + 2*y2, so to analyse whether they are linear, we only need to check the plots for y3 and y4.

It is easy to see that System 1 and System 3 are linear but System 2 is not.

### Basic Problem c

To figure out whether they are time invariant, we need to compare y1 and y2, since the input x1 and x2 have the relation $x_1[n] = x_2[n-n_0]$, so if $y_1[n] = y_2[n-n_0]$, then the system is time invariant.

It is easy to see that System 1 and System 2 are time invariant while System 3 are not.

----------------------------------------------------------------

### Intermediate Problem d

The System 1 output can be figured out by using `filter`, and to find the unit impulse response we can use unit impulse as input.

But for System 2 we cannot use filter anymore because the variable $n$ occurs outside the input signal itself. To deal with this problem, we should use a `for` loop to figure out all the members in the unit impulse response one by one.

The plots for $h_1[n]$ and $h_2[n]$ are shown below.

![Figure 2.5_a](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_d.png)

----------------------------------------------------------------

### Intermediate Problem e

From the Intermediate Problem d we have already found the unit impulse response, so for find the unit step response we can just convolve the unit step signal with the unit impulse response $h_1[n]$ and $h_2[n]$.

The plots are shown below.

![Figure 2.5_a](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_e.png)

## 2.10

### Advanced Problem f

In audio signal `y2`,  the wave satisfies the pattern

$$
y[n] =
x[n] + \alpha x[n - N].
$$

The plot of `Rxx`, which is the autocorrelation signal of `y2` is shown below.

![Figure 2.10 f (1)](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-10_f_1.png)

From the plot, we can conclude that there's a maximum peak in the center of the sampling points, which represents for the original audio signal without time delay. Next to the center peak there are two sub-maximum peaks symmetric with respect to the maximum peak, which represent the delayed audio signal.

```matlab
% to obtain the maximum peak
[p1y, p1x] = max(Rxx);

% assign 0 to the sampling points around the maximum peak
Rxx2 = Rxx;
Rxx2(p1x - 100:p1x + 100, 1) = 0;

% to obtain the sub-maximum peak
[p2y, p2x] = max(Rxx2);
```

Firstly, we find the time latency by calculating the time difference between the peaks.

```matlab
% calculate the time difference
N = abs(p1x - p2x);
```

Then, we determine the attenuation factor $\alpha$. According to the property of autocorrelation, the magnitude in autocorrelation represents the energy power contained by the wave. Hence alpha should be the square root of the ratio of values of the peaks.

```matlab
% calculate the attenuation factor alpha
alp = sqrt(p2y / p1y);
```

Therefore, the `y2` signal can be decomposed as

$$
y_2[n] =
z[n] + \alpha z[n - N],
$$

in which $\alpha = 0.7260$, $N = 501$, and $z[n]$ is the original audio signal we require.

Using `filter()`, we can obtain $z[n]$.

```matlab
% cancel the echo using filter
A2 = [1 zeros(1, N - 1) alp];
B2 = 1;
z = filter(B2, A2, y2);
```

By comparing the wave pattern of $y_2[n]$ and $z[n]$, as well as listening to the echo-canceled audio, the performance of the echo canceling process satisfies our expectation.

![Figure 2.10 f (2)](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-10_f_2.png)

The complete MATLAB script of this part is shown below.

```matlab
load lineup.mat

% obtain the autocorrelation of y2
Rxx = xcorr(y2);
figure
plot(Rxx)
title('The Auotocorrelation of y_2')
xlabel('index')
ylabel('value')

% to obtain the maximum peak
[p1y, p1x] = max(Rxx);

% assign 0 to the sampling points around the maximum peak
Rxx2 = Rxx;
Rxx2(p1x - 100:p1x + 100, 1) = 0;

% to obtain the sub-maximum peak
[p2y, p2x] = max(Rxx2);

% mark the peaks in the plot
hold on
plot(p1x, p1y, 'o')
plot(p2x, p2y, 'o')
plot(2 * p1x - p2x, p2y, 'o')

% calculate the time difference
N = abs(p1x - p2x);

% calculate the attenuation factor alpha
alp = sqrt(p2y / p1y);

% cancel the echo using filter
A2 = [1 zeros(1, N - 1) alp];
B2 = 1;
z = filter(B2, A2, y2);

% verifying the result
figure
subplot(2, 1, 1)
plot(y2)
title('y_2[n]')
subplot(2, 1, 2)
plot(z)
title('z[n]')
ylim([-10, 5])

sound(z)
```

----------------------------------------------------------------

In audio signal `y3`,  the wave satisfies the pattern

$$
y[n] =
x[n] +
\alpha_1 x[n - N_1] +
\alpha_2 x[n - N_2]
$$

The plot of `Rxx`, which is the autocorrelation signal of `y3` is shown below.

![Figure 2.10 f (3)](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-10_f_3.png)

From the plot, we can conclude that there's a maximum peak in the center of the sampling points, which represents for the original audio signal without time delay. Next to the center peak there are two sub-maximum peaks and two third-maximum peaks symmetric with respect to the maximum peak, which represent the delayed audio signal.

```matlab
% to obtain the maximum peak
[p1y, p1x] = max(Rxx);

% assign 0 to the sampling points around the maximum peak
Rxx2 = Rxx;
Rxx2(p1x - 100:p1x + 100, 1) = 0;

% to obtain the sub-maximum peak
[p2y, p2x] = max(Rxx2);

% assign 0 to the sampling points around the sub-maximum peak
Rxx3 = Rxx2;
Rxx3(p2x - 100:p2x + 100, 1) = 0;
Rxx3(2 * p1x - p2x - 100: ...
    2 * p1x - p2x + 100, 1) = 0;

% to obtain the third-maximum peak
[p3y, p3x] = max(Rxx3);
```

Firstly, we find the time latency by calculating the time difference between the peaks.

```matlab
% calculate the time difference
N1 = abs(p1x - p2x);
N2 = abs(p1x - p3x);
```

Then, we determine the attenuation factors $\alpha_1$ and $\alpha_1$. According to the property of autocorrelation, the magnitude in autocorrelation represents the energy power contained by the wave. Hence alpha should be the square root of the ratio of values of the peaks.

```matlab
% calculate the attenuation factor alpha
alpha1 = sqrt(p2y / p1y);
alpha2 = sqrt(p3y / p1y);
```

Therefore, the `y3` signal can be decomposed as

$$
y_3[n] =
z[n] +
\alpha_1 z[n - N_1] +
\alpha_2 z[n - N_2],
$$

in which $\alpha_1 = 0.5904$, $\alpha_2 = 0.5067$, $N_1 = 751$, $N_2 = 2252$, and $z[n]$ is the original audio signal we require.

Using `filter()`, we can obtain $z[n]$.

```matlab
% cancel the echo using filter
A2 = [1 zeros(1, N1 - 1) alpha1 ...
        zeros(1, N2 - N1 -1) alpha2];
B2 = 1;
z = filter(B2, A2, y3);
```

By comparing the wave pattern of $y_3[n]$ and $z[n]$, as well as listening to the echo-canceled audio, the performance of the echo canceling process satisfies our expectation.

![Figure 2.10 f (4)](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-10_f_4.png)

The complete MATLAB script of this part is shown below.

```matlab
load lineup.mat

% obtain the autocorrelation of y3
Rxx = xcorr(y3);
figure
plot(Rxx)
title('The Auotocorrelation of y_3')
xlabel('index')
ylabel('value')

% to obtain the maximum peak
[p1y, p1x] = max(Rxx);

% assign 0 to the sampling points around the maximum peak
Rxx2 = Rxx;
Rxx2(p1x - 100:p1x + 100, 1) = 0;

% to obtain the sub-maximum peak
[p2y, p2x] = max(Rxx2);

% assign 0 to the sampling points around the sub-maximum peak
Rxx3 = Rxx2;
Rxx3(p2x - 100:p2x + 100, 1) = 0;
Rxx3(2 * p1x - p2x - 100: ...
    2 * p1x - p2x + 100, 1) = 0;

% to obtain the third-maximum peak
[p3y, p3x] = max(Rxx3);

% mark the peaks in the plot
hold on
plot(p1x, p1y, 'o')
plot(p2x, p2y, 'o')
plot(p3x, p3y, 'o')
plot(2 * p1x - p2x, p2y, 'o')
plot(2 * p1x - p3x, p3y, 'o')

% calculate the time difference
N1 = abs(p1x - p2x);
N2 = abs(p1x - p3x);

% calculate the attenuation factor alpha
alpha1 = sqrt(p2y / p1y);
alpha2 = sqrt(p3y / p1y);

% cancel the echo using filter
A2 = [1 zeros(1, N1 - 1) alpha1 ...
        zeros(1, N2 - N1 -1) alpha2];
B2 = 1;
z = filter(B2, A2, y3);

% verifying the result
figure
subplot(2, 1, 1)
plot(y3)
title('y_3[n]')
subplot(2, 1, 2)
plot(z)
ylim([-10, 5])
title('z[n]')

sound(z)
```
