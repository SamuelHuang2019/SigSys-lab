# Report of Signals and Systems Lab Assignment 2

Written by HUANG Guanchao, SID 11912309 and GONG Xinrui, SID 11911233.

----------------------------------------------------------------

## 2.4

### Basic Problem a 

The plots of x1[n],h1[n] and h2[n] are shown below.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nh1 = 0:4;
x1 = [ones(1, 5) zeros(1, 5)];
h1 = [1 -1 3 0 1];
h2 = [0 2 5 4 -1];

subplot(3, 1, 1)
stem(nx1, x1), axis([0, 9, ylim])
xlabel('nx1'); 
ylabel('Output')
subplot(3, 1, 2), stem(nh1, h1), axis([0, 9, ylim])
xlabel('nh1'); ylabel('Output')
subplot(3, 1, 3), stem(nh1, h2), axis([0, 9, ylim])
xlabel('nh2'); ylabel('Output')

```

----------------------------------------------------------------

### Basic Problem b

The outputs are the same.

We first find convolved x1 with h1, which is `x1[n] * h1[n]`, then we change `x1[n]` into the impulse response and `h1[n]` into the input, and make convolution again, which is `x1[n] * h1[n]`.

The plots for them are shown below, and we can easily figure out that `x1[n] * h1[n]` equals to `x1[n] * h1[n]`.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_b.png)

The MATLAB script is shown above.

```matlab
nx1 = 0:9;
nh1 = 0:4;
x1 = [ones(1,5) zeros(1,5)];
h1 = [1 -1 3 0 1];
h2 = [0 2 5 4 -1];

nw = 0:13;
w1 = conv(x1,h1);
w2 = conv(h1,x1);


subplot(2,1,1),stem(nw,w1),axis([0,13,ylim])
xlabel('nw');ylabel('Output');title('w1[n]=x1[n]*h1[n]')
subplot(2,1,2),stem(nw,w1),axis([0,13,ylim])
xlabel('nw');ylabel('Output');title('w1[n]=h1[n]*x1[n]')

```

----------------------------------------------------------------

### Basic Problem c

The two methods give the same results.

We first convolved `x1[n]*h1[n]` and `x1[n]*h2[n]` separately, and then add them together and find out the plot. After that, we try to add `h1[n]` and `h2[n]` first, and convolved `x1[n]*(h1[n]+h2[n])`.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_c.png)

The two plots are shown above, and we can see that they are exactly the same, which means they have the same results.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nh1 = 0:4;
x1 = [ones(1, 5) zeros(1, 5)];
h1 = [1 -1 3 0 1];
h2 = [0 2 5 4 -1];
h3 = h1 + h2;

nw = 0:13;
w1 = conv(x1, h1) + conv(x1, h2);
w2 = conv(x1, h3);

subplot(2, 1, 1), stem(nw, w1), axis([0, 13, ylim])
xlabel('n_w'); ylabel('w_1')
title('w_1[n] = x_1[n] * h_1[n] + x_1[n] * h_2[n]')
subplot(2, 1, 2)
stem(nw, w2)
axis([0, 13, ylim])
xlabel('n_w')
ylabel('w_2')
title('w_2[n] = x_1[n] * (h_1[n] + h_2[n])')
```

----------------------------------------------------------------

### Basic Problem d

Compairing $y_{d1}[n]$ and $y_{d2}[n]$ ,we have the same results.

First we calculate `x1[n]* h1[n]` and then we use this result to convolved with `h2[n]`.Next we calculate the `h1[n]* h2[n]` firstly and then use the output as the impulse response to convolved with `x1[n]`.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_d.png)

The two plots are shown above, it can be apparently concluded that the output are the same.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nh1 = 0:4;
x1 = [ones(1,5) zeros(1,5)];
h1 = [1 -1 3 0 1];
h2 = [0 2 5 4 -1];

nw = 0:13;

h3 = conv(x1, h1);
h4 = conv(h1, h2);

w1 = conv(h3,h2);
nw1 = 0:17;
w2 = conv(x1,h4);
nw2 = 0:17;

subplot(2,1,1),stem(nw1,w1),axis([0,17,ylim])
xlabel('nw1');ylabel('(x1[n]*h1[n]])*h2[n]');
subplot(2,1,2),stem(nw2,w2),axis([0,17,ylim])
xlabel('nw2');ylabel('x1[n]*(h1[n]*h2[n])');
```

----------------------------------------------------------------

### Intermediate Problem e

For this question, we convolved $x_1[n]*h_{e1}[n]$ and $x_2[n]*h_{e}2[n]$, where $h_{e1}[n]$ and $h_{e2}[n]$ have the relationship $h_{e2}[n] = hg_{e1}[n-n_0]$.

The two plots are shown below.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_e.png)

We can easily conclude from the plots that $y_{e2}[n] = y_{e1}[n-n_0]$.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nh1 = 0:4;
nh2 = 2:6;
x1 = [ones(1,5) zeros(1,5)];
h1 = [1 -1 3 0 1];
h2 = h1;

ny1 = nx1(1)+nh1(1):nx1(end)+nh1(end);
ny2 = nx1(1)+nh2(1):nx1(end)+nh2(end);
y1 = conv(x1,h1);
y2 = conv(x1,h2);

subplot(2,1,1),stem(ny1,y1),axis([0,15,ylim])
xlabel('n');ylabel('ye1 = x1[n]*he1[n]');title('ye1');
subplot(2,1,2),stem(ny2,y2),axis([0,15,ylim])
xlabel('n');ylabel('ye2 = x1[n]*he2[n]');title('ye2');
```

----------------------------------------------------------------

### Intermediate Problem f

To finds out the two outputs, we should first figure out the output of system 1, which is $(n+1).*x_1[n]$. Then we use the output as the input of System 2, and use $h_{f2}[n]$ as the impulse response to get the output $y_{f1}[n]$.

Another try is that we first convolved $h_{f1}[n]$ with $h_{f2}[n]$, then we use the result as the impulse response to convolved with $x_1[n]$, the convolution result is named as $y_{f2}[n]$.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_f.png)

We can easily conclude from the plots that they are not equal to each other.

The MATLAB script is shown below.

```matlab
nx1 = 0:9;
nhf2 = 0:4;
x1 = [ones(1, 5) zeros(1, 5)];
hf2 = [1 -1 3 0 1];

w = (nx1 + 1) .* x1;

yf1 = conv(w, hf2);
nyf1 = nx1(1) + nhf2(1):nx1(end) + nhf2(end);

xf1 = [1 zeros(1, 4)];
hf1 = (nhf2 + 1) .* xf1;

hseries = conv(hf1, hf2);
nhseries = nhf2(1) + nhf2(1):nhf2(end) + nhf2(end);

yf2 = conv(x1, hseries);
nyf2 = nx1(1) + nhseries(1):nx1(end) + nhseries(end);

subplot(2, 1, 1), stem(nyf1, yf1), axis([0, 17, ylim])
xlabel('n'); ylabel('yf1 = w[n]*hf2[n]'); title('yf1');
subplot(2, 1, 2), stem(nyf2, yf2), axis([0, 17, ylim])
xlabel('n'); ylabel('yf2 = x1[n]*(hf1[n]*hf2[n]'); title('yf2');
```

----------------------------------------------------------------

### Intermediate Problem g

To find out the two output signals, we first need to find out the signal $x_g[n]$, and then use this signal as input signal for System 1 to find out the output signal $y_{ga}[n]$.Then we use the output of System 1 as the input signal for System 2. And the output $y_{gb}[n]$ is the convolution of $y_{ga}[n]$ and $h_{g2}[n]$.$y_{g1}[n]$ is the result of add $y_{ga}[n]$ and $y_{gb}[n]$ together, which is `yg1 = yga + ygb`.

For another try, we first figure out the unit impulse response for System 1 by letting the input signal be unit impulse signal. Then we add this response signal $h_{g1}[n]$  with $h_{g2}[n]$. After that we convolved $x_g[n]$ with this result, so now we get the $y_{g2}[n]$ which is `yg2 = xg * (hg1 + hg2)`.

The two plots for $y_{g1}[n]$ and $y_{g2}[n]$ are shown below.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-4_g.png)

It is obvious that they are the same, which means $y_{g1}[n] = y_{g2}[n]$.

The MATLAB script is shown below.

```matlab
n = 0:4;
x = [1 zeros(1,4)];
hg2 = [0 2 5 4 -1];
xg = 2.*x;

yga = xg.^2;
ygb = conv(xg,hg2);
nygb = 0:8;
yg1 = [yga zeros(1,4)] + ygb;
nyg1 = 0:8;

hg1 = x.^2;
hparallel = hg1 + hg2;
yg2 = conv(xg,hparallel);
nyg2 = 0:8;

subplot(2,1,1),stem(nyg1,yg1),axis([0,8,ylim])
xlabel('n');ylabel('yg1 = xg*hga + xg*hgb');title('yg1');
subplot(2,1,2),stem(nyg2,yg2),axis([0,8,ylim])
xlabel('n');ylabel('yf2 = xg*(hg1 + hg2)');title('yg2');
```

----------------------------------------------------------------

## 2.5

### Basic Problem a

Basic problems a,b,c use the same Systems, so first we plot the Systems' outputs.

For System 1, it is not easy to figure out the expression for y using x quickly, so use vector to record their index and count the result using `filter`.

The plot is shown below.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_a.png)

For System2, we simply use `cos()` to find out the result.

The plot is shown below.

![Figure 2.4_b](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_a(2).png)

For System 3, we calculated the results using point multiplication, which is `n.*x[n]`.

The plot is shown below.

![Figure 2.5_a](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_a(3).png)

### Basic Problem b

Since for all three systems the input x3 = x1 + 2*x2, and the output y4 = y1 + 2*y2, so to analyse whether they are linear, we only need to check the plots for y3 and y4. 

It is easy to see that System 1 and System 3 are linear but System 2 is not.

### Basic Problem c

To figure out whether they are time invariant, we need to compare y1 and y2, since the input x1 and x2 have the relation $x_1[n] = x_2[n-n_0]$, so if $y_1[n] = y_2[n-n_0]$, then the system is time invariant.

It is easy to see that System 1 and System 2 are time invariant while System 3 are not.

----------------------------------------------------------------

### Intermediate Problem d

The System 1 output can be figured out by using `filter`, and to find the unit impulse response we can use unit impulse as input.

But for System 2 we cannot use filter anymore because the variable $n$ occurs outside the input signal itself. To deal with this problem, we should use a `for` loop to figure out all the members in the unit impulse response one by one.

The plots for $h_1[n]$ and $h_2[n]$ are shown below.

![Figure 2.5_a](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_d.png)

----------------------------------------------------------------

### Intermediate Problem e

From the Intermediate Problem d we have already found the unit impulse response, so for find the unit step response we can just convolve the unit step signal with the unit impulse response $h_1[n]$ and $h_2[n]$, which is $x_1[n]*h_1[n]$ and $x_1[n]*h_2[n]$.

The plots are shown below.

<<<<<<< Updated upstream
![Figure 2.5_a](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_e.png)

## 2.10
=======
![Figure 2.5_e](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_e.png)
>>>>>>> Stashed changes

The MATLAB script is shown below.

```matlab
n = 0:19;
x1 = ones(1,20);
%System1
a1 = [1 -0.6];
b1 = [1 0];
h1 = filter(b1,a1,x);
%System2
h2 = zeros(1,20);
h2(1) = 1;%cuz h2(i) = 0 if i <1, h2[0] = x[0] = 1, h2[1] = h2[0] + 0;
for i= 1:19
    h2(i+1) = 0.6^i*h2(i) +x(i+1);
end

s1 = conv(x1,h1);
ns1 = 0:38;
s2 = conv(x1,h2);
ns2 = 0:38;

subplot(2,1,1)
stem(ns1,s1),axis([0,38,ylim])
xlabel('n');
ylabel('s1');
title('s1[n] = x[n]*h1[n]');
subplot(2,1,2)
stem(ns2,s2),axis([0,38,ylim])
xlabel('n');
ylabel('s2');
title('s2[n] = x[n]*h2[n]');
```

----------------------------------------------------------------

### Intermediate Problem f

To finds out the results, all we need to do is to change the order of the convolution in Intermediate Problem e, which is now $h_1[n]*x_1[n]$ and $h_2[n]*x_1[n]$.

The plots are shown below.

![Figure 2.5_f](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_f.png)

The MATLAB script is shown below.

```matlab
n = 0:19;
x1 = ones(1,20);
%System1
a1 = [1 -0.6];
b1 = [1 0];
h1 = filter(b1,a1,x);
%System2
h2 = zeros(1,20);
h2(1) = 1;%cuz h2(i) = 0 if i <1, h2[0] = x[0] = 1, h2[1] = h2[0] + 0;
for i= 1:19
    h2(i+1) = 0.6^i*h2(i) +x(i+1);
end

z1 = conv(h1,x1);
nz1 = 0:38;
z2 = conv(h2,x1);
nz2 = 0:38;

subplot(2,1,1)
stem(nz1,z1),axis([0,38,ylim])
xlabel('n');
ylabel('z1');
title('z1[n] = h1[n]*x[n]');
subplot(2,1,2)
stem(ns2,s2),axis([0,38,ylim])
xlabel('n');
ylabel('z2');
title('z2[n] = h2[n]*x[n]');
```

----------------------------------------------------------------

### Intermediate Problem g

THe plots for s1，z1，s2 and z2 have already been graphed in problem e and f, and now we place the two plots in one graph.

The plot is shown below.

![Figure 2.5_f](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_g.png)

![Figure 2.5_f](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-5_g(2).png)

It is obvious that s1 equals to z1 and s2 equals to z2. The reason is that for LTI System, commutatiice law is correct for convolution. 

The MATLAB script is shown below.

```matlab
n = 0:19;
x = [1 zeros(1, 19)];
x1 = ones(1, 20);
%System1
a1 = [1 -0.6];
b1 = [1 0];
h1 = filter(b1, a1, x);
%System2
h2 = zeros(1, 20);
h2(1) = 1; %cuz h2(i) = 0 if i <1, h2[0] = x[0] = 1, h2[1] = h2[0] + 0;

for i = 1:19
    h2(i + 1) = 0.6^i * h2(i) +x(i + 1);
end

%The four outputs
z1 = conv(h1, x1);
nz1 = 0:38;
s1 = conv(x1, h1);
ns1 = 0:38;
z2 = conv(h2, x1);
nz2 = 0:38;
s2 = conv(x1, h2);
ns2 = 0:38;

stem(ns1, s1, 'o'), axis([0, 38, ylim])
hold on;
stem(nz1, z1, '*'), axis([0, 38, ylim])
xlabel('n');
ylabel('Output');
title('s1 and z1');
legend('s1', 'z1');

stem(ns2, s2, 'o'), axis([0, 38, ylim])
hold on;
stem(nz2, z2, '*'), axis([0, 38, ylim])
xlabel('n');
ylabel('Output');
title('s2 and z2');
legend('s2', 'z2');
```

----------------------------------------------------------------

## 2.10

### Basic Problem a

For this question we need to find out the unit impulse response for the System $y[n] = x[n] + \alpha x[n-N]$, and $\alpha = 0.5$ and $N = 1000$. So we use $\delta [n]$ as the input and sort the range $0 \le n \le 1000$, calculate the output and store it in vector `he`.

The plot is shown below.

![Figure 2.5_f](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-10_a.png)

----------------------------------------------------------------

### Basic Problem b

We now should deal with $z[n] + \alpha z[n-N] = y[n]$, where $\alpha = 0.5$ and $N = 1000$, the same condition as problem a.However, because we cannot find out the expression of $z[n]$ directly, so we use the function `filter` to calculate `z` then, the index vector for output is `[1 0.5]` and the index vector for input is `[1]`. Also , the input signal is the result of problem a.

The plot is shown below.

![Figure 2.5_f](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-10_b.png)

The output is a unit impulse signal, the same as $x[n]$. So $z[n] = x[n]$. 

The MATLAB script is shown below.

```matlab
n = 0:1000;
x = [1 zeros(1, 1000)];
a1 = 1;
b1 = [1 zeros(1, 999) 0.5];
y1 = filter(b1, a1, x);

a2 = [1 zeros(1, 999) 0.5];
b2 = 1;
z1 = filter(b2, a2, y1);

stem(n, z1);
xlabel('n');
ylabel('z1');
title('z[n]+0.5*z-[n-1000] = y[n]');
```

----------------------------------------------------------------

### Intermediate Problem c

This problem is similar to problem a and the only difference between them is the sorted range for unit impulse signal $\delta [n]$ is $0 \le n \le 4000$. We store this output in vector `her`.

The plot is shown below.

![Figure 2.5_f](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-10_c.png)

The MATLAB script is shown below.

```matlab
n = 0:4000;
d = [1 zeros(1, 4000)];
a1 = [1 zeros(1, 3999) 0.5];
b1 = 1;

her = filter(b1, a1, d);

stem(n, her);
xlabel('n');
ylabel('her');
title('impulse response for d');
```

----------------------------------------------------------------

### Intermediate Problem d

By using `z = filter(1,a,y)`, we can clearly see the differences between the original sound and the sound without echo. 

The plot is shown below.

![Figure 2.5_f](https://raw.githubusercontent.com/SamuelHuang2019/SigSys-lab/master/figures/A2_2-10_d.png)

The MATLAB script is shown below.



----------------------------------------------------------------

### Intermediate Problem d

The 